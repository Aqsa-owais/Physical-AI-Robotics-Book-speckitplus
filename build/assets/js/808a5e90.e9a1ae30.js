"use strict";(globalThis.webpackChunkphysical_ai_robotics_book=globalThis.webpackChunkphysical_ai_robotics_book||[]).push([[35],{1830:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-ai-brain/navigation","title":"Navigation and Path Planning using Nav2","description":"Introduction","source":"@site/docs/module-3-ai-brain/navigation.md","sourceDirName":"module-3-ai-brain","slug":"/module-3-ai-brain/navigation","permalink":"/giaic-hackathon-speckit-plus/docs/module-3-ai-brain/navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3-ai-brain/navigation.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Visual SLAM and Localization","permalink":"/giaic-hackathon-speckit-plus/docs/module-3-ai-brain/slam-localization"},"next":{"title":"Sim-to-Real Transfer Concepts","permalink":"/giaic-hackathon-speckit-plus/docs/module-3-ai-brain/sim-to-real"}}');var o=a(4848),i=a(8453);const r={sidebar_position:9},s="Navigation and Path Planning using Nav2",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Navigation Architecture",id:"navigation-architecture",level:2},{value:"Nav2 System Overview",id:"nav2-system-overview",level:3},{value:"Key Components",id:"key-components",level:3},{value:"1. Global Planner",id:"1-global-planner",level:4},{value:"2. Local Planner",id:"2-local-planner",level:4},{value:"Nav2 Configuration",id:"nav2-configuration",level:2},{value:"Basic Nav2 Configuration File",id:"basic-nav2-configuration-file",level:3},{value:"Nav2 Launch File",id:"nav2-launch-file",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"A* Path Planning Implementation",id:"a-path-planning-implementation",level:3},{value:"Dijkstra&#39;s Algorithm Implementation",id:"dijkstras-algorithm-implementation",level:3},{value:"Behavior Trees in Navigation",id:"behavior-trees-in-navigation",level:2},{value:"Custom Behavior Tree Nodes",id:"custom-behavior-tree-nodes",level:3},{value:"Navigation with Isaac ROS Integration",id:"navigation-with-isaac-ros-integration",level:2},{value:"Isaac ROS Perception Integration",id:"isaac-ros-perception-integration",level:3},{value:"Navigation Recovery Behaviors",id:"navigation-recovery-behaviors",level:2},{value:"Custom Recovery Behaviors",id:"custom-recovery-behaviors",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Multi-Level Path Planning",id:"multi-level-path-planning",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Navigation Failures",id:"1-navigation-failures",level:3},{value:"2. Oscillation in Path Following",id:"2-oscillation-in-path-following",level:3},{value:"3. Local Minima in Navigation",id:"3-local-minima-in-navigation",level:3},{value:"4. Performance Issues",id:"4-performance-issues",level:3},{value:"Integration with Isaac ROS",id:"integration-with-isaac-ros",level:2},{value:"Launch Configuration for Isaac ROS Navigation",id:"launch-configuration-for-isaac-ros-navigation",level:3},{value:"Summary",id:"summary",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"navigation-and-path-planning-using-nav2",children:"Navigation and Path Planning using Nav2"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"Navigation is a critical capability for autonomous robots, enabling them to move safely and efficiently from one location to another in complex environments. The Navigation2 (Nav2) stack is the state-of-the-art navigation framework for ROS 2, providing a complete solution for robot navigation including path planning, path following, obstacle avoidance, and recovery behaviors."}),"\n",(0,o.jsx)(e.p,{children:"This guide covers the fundamentals of navigation and path planning using Nav2, including system architecture, configuration, and integration with perception systems."}),"\n",(0,o.jsx)(e.h2,{id:"navigation-architecture",children:"Navigation Architecture"}),"\n",(0,o.jsx)(e.h3,{id:"nav2-system-overview",children:"Nav2 System Overview"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 follows a behavior tree architecture that allows for flexible and robust navigation behaviors:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-text",children:"Nav2 System\n\u251c\u2500\u2500 Navigation Server\n\u2502   \u251c\u2500\u2500 Lifecycle Manager\n\u2502   \u251c\u2500\u2500 Behavior Tree Engine\n\u2502   \u2514\u2500\u2500 Action Servers\n\u251c\u2500\u2500 Planner Server\n\u2502   \u251c\u2500\u2500 Global Planner (A*, Dijkstra, etc.)\n\u2502   \u2514\u2500\u2500 Local Planner (DWA, TEB, etc.)\n\u251c\u2500\u2500 Controller Server\n\u2502   \u251c\u2500\u2500 Path Following Controller\n\u2502   \u2514\u2500\u2500 Velocity Smoothing\n\u251c\u2500\u2500 Recovery Server\n\u2502   \u251c\u2500\u2500 Spin Recovery\n\u2502   \u251c\u2500\u2500 Backup Recovery\n\u2502   \u2514\u2500\u2500 Wait Recovery\n\u2514\u2500\u2500 Map Server\n    \u251c\u2500\u2500 Static Map Server\n    \u2514\u2500\u2500 Costmap Server\n"})}),"\n",(0,o.jsx)(e.h3,{id:"key-components",children:"Key Components"}),"\n",(0,o.jsx)(e.h4,{id:"1-global-planner",children:"1. Global Planner"}),"\n",(0,o.jsx)(e.p,{children:"The global planner computes a path from start to goal in the static map:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"// Example C++ code for custom global planner plugin\n#include <nav2_core/global_planner.hpp>\n#include <nav2_costmap_2d/costmap_2d_ros.hpp>\n#include <geometry_msgs/msg/pose_stamped.hpp>\n\nclass CustomGlobalPlanner : public nav2_core::GlobalPlanner\n{\npublic:\n    void configure(\n        const rclcpp_lifecycle::LifecycleNode::WeakPtr& parent,\n        std::string name,\n        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros,\n        std::shared_ptr<nav2_costmap_2d::Costmap2D> global_costmap,\n        std::string local_footprint_str) override\n    {\n        node_ = parent.lock();\n        name_ = name;\n        costmap_ = costmap_ros->getCostmap();\n        global_frame_ = costmap_ros->getGlobalFrameID();\n    }\n\n    void cleanup() override {}\n\n    void activate() override {}\n\n    void deactivate() override {}\n\n    nav_msgs::msg::Path createPlan(\n        const geometry_msgs::msg::PoseStamped& start,\n        const geometry_msgs::msg::PoseStamped& goal) override\n    {\n        nav_msgs::msg::Path path;\n\n        // Implement path planning algorithm (e.g., A* or Dijkstra)\n        if (computePath(start, goal, path)) {\n            return path;\n        } else {\n            // Return empty path if no path found\n            return nav_msgs::msg::Path{};\n        }\n    }\n\nprivate:\n    bool computePath(const geometry_msgs::msg::PoseStamped& start,\n                     const geometry_msgs::msg::PoseStamped& goal,\n                     nav_msgs::msg::Path& path)\n    {\n        // Implementation of path planning algorithm\n        // This is a simplified example\n        path.poses.resize(10);  // Example path with 10 points\n\n        for (int i = 0; i < 10; ++i) {\n            geometry_msgs::msg::PoseStamped pose;\n            pose.header.frame_id = global_frame_;\n            pose.pose.position.x = start.pose.position.x +\n                                  (goal.pose.position.x - start.pose.position.x) * i / 10.0;\n            pose.pose.position.y = start.pose.position.y +\n                                  (goal.pose.position.y - start.pose.position.y) * i / 10.0;\n            pose.pose.orientation.w = 1.0;  // No rotation\n            path.poses[i] = pose;\n        }\n\n        return true;  // Path found\n    }\n\n    rclcpp_lifecycle::LifecycleNode::SharedPtr node_;\n    std::string name_;\n    std::string global_frame_;\n    nav2_costmap_2d::Costmap2D* costmap_;\n};\n"})}),"\n",(0,o.jsx)(e.h4,{id:"2-local-planner",children:"2. Local Planner"}),"\n",(0,o.jsx)(e.p,{children:"The local planner follows the global path while avoiding obstacles:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example Python code for local planning (conceptual)\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom nav_msgs.msg import Path, Odometry\nfrom sensor_msgs.msg import LaserScan\nimport numpy as np\n\nclass LocalPlanner(Node):\n    def __init__(self):\n        super().__init__(\'local_planner\')\n\n        # Subscriptions\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10)\n        self.laser_sub = self.create_subscription(\n            LaserScan, \'/scan\', self.laser_callback, 10)\n        self.global_plan_sub = self.create_subscription(\n            Path, \'/global_plan\', self.global_plan_callback, 10)\n\n        # Publisher\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n\n        # Current state\n        self.current_pose = None\n        self.current_twist = None\n        self.laser_data = None\n        self.global_plan = None\n        self.current_plan_idx = 0\n\n        # Local planner parameters\n        self.lookahead_dist = 0.5\n        self.max_vel = 0.5\n        self.max_ang_vel = 1.0\n        self.safety_dist = 0.3\n\n    def odom_callback(self, msg):\n        """Update current pose and twist from odometry"""\n        self.current_pose = msg.pose.pose\n        self.current_twist = msg.twist.twist\n\n    def laser_callback(self, msg):\n        """Update laser scan data"""\n        self.laser_data = msg\n\n    def global_plan_callback(self, msg):\n        """Update global plan"""\n        self.global_plan = msg.poses\n        self.current_plan_idx = 0\n\n    def compute_velocity_commands(self):\n        """Compute velocity commands based on global plan and local obstacles"""\n        if not self.global_plan or not self.laser_data or not self.current_pose:\n            return Twist()\n\n        # Get next point on global plan\n        target_point = self.get_next_waypoint()\n        if not target_point:\n            return Twist()  # Stop if no target\n\n        # Calculate desired direction\n        dx = target_point.pose.position.x - self.current_pose.position.x\n        dy = target_point.pose.position.y - self.current_pose.position.y\n        dist_to_target = np.sqrt(dx*dx + dy*dy)\n\n        # Calculate desired angle\n        desired_angle = np.arctan2(dy, dx)\n\n        # Get current robot angle\n        current_angle = self.quaternion_to_yaw(self.current_pose.orientation)\n\n        # Calculate angle error\n        angle_error = self.normalize_angle(desired_angle - current_angle)\n\n        # Create velocity command\n        cmd_vel = Twist()\n\n        # Check for obstacles\n        if self.has_obstacles_ahead():\n            # Emergency stop or obstacle avoidance\n            cmd_vel.linear.x = 0.0\n            cmd_vel.angular.z = self.avoid_obstacles()\n        else:\n            # Move toward target\n            cmd_vel.linear.x = min(self.max_vel * dist_to_target, self.max_vel)\n            cmd_vel.angular.z = self.max_ang_vel * angle_error\n\n        return cmd_vel\n\n    def get_next_waypoint(self):\n        """Get next waypoint on global plan"""\n        if not self.global_plan or self.current_plan_idx >= len(self.global_plan):\n            return None\n\n        # Find next waypoint within lookahead distance\n        for i in range(self.current_plan_idx, len(self.global_plan)):\n            wp = self.global_plan[i]\n            dx = wp.pose.position.x - self.current_pose.position.x\n            dy = wp.pose.position.y - self.current_pose.position.y\n            dist = np.sqrt(dx*dx + dy*dy)\n\n            if dist >= self.lookahead_dist:\n                self.current_plan_idx = i\n                return wp\n\n        # Return last waypoint if reached end of plan\n        return self.global_plan[-1] if self.global_plan else None\n\n    def has_obstacles_ahead(self):\n        """Check if there are obstacles in front of robot"""\n        if not self.laser_data:\n            return False\n\n        # Check laser readings in front of robot\n        front_idx = len(self.laser_data.ranges) // 2\n        scan_width = len(self.laser_data.ranges) // 8  # Check ~45 degrees in front\n\n        for i in range(front_idx - scan_width//2, front_idx + scan_width//2):\n            if 0 < self.laser_data.ranges[i] < self.safety_dist:\n                return True\n\n        return False\n\n    def avoid_obstacles(self):\n        """Simple obstacle avoidance behavior"""\n        if not self.laser_data:\n            return 0.0\n\n        # Simple strategy: turn away from closest obstacle\n        min_dist = float(\'inf\')\n        min_idx = len(self.laser_data.ranges) // 2\n\n        for i, dist in enumerate(self.laser_data.ranges):\n            if 0 < dist < min_dist:\n                min_dist = dist\n                min_idx = i\n\n        # Turn away from obstacle\n        center_idx = len(self.laser_data.ranges) // 2\n        if min_idx < center_idx:\n            # Obstacle on the left, turn right\n            return -self.max_ang_vel\n        else:\n            # Obstacle on the right, turn left\n            return self.max_ang_vel\n\n    def quaternion_to_yaw(self, quat):\n        """Convert quaternion to yaw angle"""\n        siny_cosp = 2 * (quat.w * quat.z + quat.x * quat.y)\n        cosy_cosp = 1 - 2 * (quat.y * quat.y + quat.z * quat.z)\n        return np.arctan2(siny_cosp, cosy_cosp)\n\n    def normalize_angle(self, angle):\n        """Normalize angle to [-pi, pi] range"""\n        while angle > np.pi:\n            angle -= 2 * np.pi\n        while angle < -np.pi:\n            angle += 2 * np.pi\n        return angle\n'})}),"\n",(0,o.jsx)(e.h2,{id:"nav2-configuration",children:"Nav2 Configuration"}),"\n",(0,o.jsx)(e.h3,{id:"basic-nav2-configuration-file",children:"Basic Nav2 Configuration File"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Navigation configuration file: nav2_params.yaml\namcl:\n  ros__parameters:\n    use_sim_time: False\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_link"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.25\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n    scan_topic: scan\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: False\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    default_nav_through_poses_bt_xml: /opt/ros/foxy/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery.xml\n    default_nav_to_pose_bt_xml: /opt/ros/foxy/share/nav2_bt_navigator/behavior_trees/navigate_w_replanning_and_recovery.xml\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_compute_path_through_poses_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_have_reached_goal_condition_bt_node\n    - nav2_are_paths_valid_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_single_trigger_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: False\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Progress checker parameters\n    progress_checker:\n      plugin: "nav2_controller::SimpleProgressChecker"\n      required_movement_radius: 0.5\n      movement_time_allowance: 10.0\n\n    # Goal checker parameters\n    goal_checker:\n      plugin: "nav2_controller::SimpleGoalChecker"\n      xy_goal_tolerance: 0.25\n      yaw_goal_tolerance: 0.25\n      stateful: True\n\n    # DWB parameters\n    FollowPath:\n      plugin: "nav2_rotation_shim_controller::RotationShimController"\n      primary_controller: "dwb_core::DWBLocalPlanner"\n      smooth_rotate: True\n\n      # DWB Core parameters\n      dwb_core:\n        plugin: "dwb_core::DWBLocalPlanner"\n        debug_trajectory_details: True\n        min_vel_x: 0.0\n        min_vel_y: 0.0\n        max_vel_x: 0.5\n        max_vel_y: 0.0\n        max_vel_theta: 1.0\n        min_speed_xy: 0.0\n        max_speed_xy: 0.5\n        min_speed_theta: 0.0\n        acc_lim_x: 2.5\n        acc_lim_y: 0.0\n        acc_lim_theta: 3.2\n        decel_lim_x: -2.5\n        decel_lim_y: 0.0\n        decel_lim_theta: -3.2\n        vx_samples: 20\n        vy_samples: 5\n        vtheta_samples: 20\n        sim_time: 1.7\n        linear_granularity: 0.05\n        angular_granularity: 0.1\n        transform_tolerance: 0.2\n        xy_goal_tolerance: 0.25\n        trans_stopped_velocity: 0.25\n        short_circuit_trajectory_evaluation: True\n        stateful: True\n        critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]\n        BaseObstacle.scale: 0.02\n        PathAlign.scale: 32.0\n        PathAlign.forward_point_distance: 0.1\n        GoalAlign.scale: 24.0\n        GoalAlign.forward_point_distance: 0.1\n        PathDist.scale: 32.0\n        GoalDist.scale: 24.0\n        RotateToGoal.scale: 32.0\n        RotateToGoal.slowing_factor: 5.0\n        RotateToGoal.lookahead_time: -1.0\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: False\n      rolling_window: false\n      width: 100\n      height: 100\n      resolution: 0.05\n      origin_x: -50.0\n      origin_y: -50.0\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      always_send_full_costmap: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: False\n      rolling_window: True\n      width: 3\n      height: 3\n      resolution: 0.05\n      origin_x: -1.5\n      origin_y: -1.5\n      plugins: ["voxel_layer", "inflation_layer"]\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      always_send_full_costmap: True\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 20.0\n    use_sim_time: False\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner/NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n\nrecoveries_server:\n  ros__parameters:\n    costmap_topic: local_costmap/costmap_raw\n    footprint_topic: local_costmap/published_footprint\n    cycle_frequency: 10.0\n    recovery_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_recoveries/Spin"\n      sim_granularity: 0.017\n      angle: 1.57\n    backup:\n      plugin: "nav2_recoveries/BackUp"\n      sim_granularity: 0.0044\n      duration: 10.0\n      backup_vel: -0.025\n    wait:\n      plugin: "nav2_recoveries/Wait"\n      sim_time: 5.0\n\nwaypoint_follower:\n  ros__parameters:\n    loop_rate: 20\n    stop_on_failure: false\n    waypoint_task_executor_plugin: "wait_at_waypoint"\n    wait_at_waypoint:\n      plugin: "nav2_waypoint_follower::WaitAtWaypoint"\n      enabled: true\n      waypoint_pause_duration: 200\n'})}),"\n",(0,o.jsx)(e.h3,{id:"nav2-launch-file",children:"Nav2 Launch File"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Navigation launch file: navigation_launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    namespace = LaunchConfiguration('namespace')\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    autostart = LaunchConfiguration('autostart')\n    params_file = LaunchConfiguration('params_file')\n    default_bt_xml_filename = LaunchConfiguration('default_bt_xml_filename')\n    map_subscribe_transient_local = LaunchConfiguration('map_subscribe_transient_local')\n\n    declare_namespace_cmd = DeclareLaunchArgument(\n        'namespace',\n        default_value='',\n        description='Top-level namespace')\n\n    declare_use_sim_time_cmd = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='false',\n        description='Use simulation (Gazebo) clock if true')\n\n    declare_autostart_cmd = DeclareLaunchArgument(\n        'autostart',\n        default_value='true',\n        description='Automatically startup the nav2 stack')\n\n    declare_params_file_cmd = DeclareLaunchArgument(\n        'params_file',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('my_robot_navigation'),\n            'config',\n            'nav2_params.yaml'\n        ]),\n        description='Full path to the ROS2 parameters file to use for all launched nodes')\n\n    declare_bt_xml_cmd = DeclareLaunchArgument(\n        'default_bt_xml_filename',\n        default_value=PathJoinSubstitution([\n            FindPackageShare('nav2_bt_navigator'),\n            'behavior_trees',\n            'navigate_w_replanning_and_recovery.xml'\n        ]),\n        description='Full path to the behavior tree xml file to use')\n\n    declare_map_subscribe_transient_local_cmd = DeclareLaunchArgument(\n        'map_subscribe_transient_local',\n        default_value='true',\n        description='Whether to set the map subscriber QoS to transient local')\n\n    # Navigation Server\n    start_nav2_node = Node(\n        package='nav2_navigation_server',\n        executable='navigation_server',\n        output='screen',\n        parameters=[params_file],\n        remappings=[('/tf', 'tf'),\n                   ('/tf_static', 'tf_static')]\n    )\n\n    # Planner Server\n    start_planner_server = Node(\n        package='nav2_planner_server',\n        executable='planner_server',\n        output='screen',\n        parameters=[params_file],\n        remappings=[('/tf', 'tf'),\n                   ('/tf_static', 'tf_static')]\n    )\n\n    # Controller Server\n    start_controller_server = Node(\n        package='nav2_controller_server',\n        executable='controller_server',\n        output='screen',\n        parameters=[params_file],\n        remappings=[('/tf', 'tf'),\n                   ('/tf_static', 'tf_static')]\n    )\n\n    # BT Navigator\n    start_bt_navigator = Node(\n        package='nav2_bt_navigator',\n        executable='bt_navigator',\n        output='screen',\n        parameters=[params_file, {\n            'default_bt_xml_filename': default_bt_xml_filename}],\n        remappings=[('/tf', 'tf'),\n                   ('/tf_static', 'tf_static')]\n    )\n\n    # Lifecycle Manager\n    start_lifecycle_manager = Node(\n        package='nav2_lifecycle_manager',\n        executable='lifecycle_manager',\n        name='lifecycle_manager_navigation',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time},\n                   {'autostart': autostart},\n                   {'node_names': ['navigation_server',\n                                  'planner_server',\n                                  'controller_server',\n                                  'bt_navigator']}]\n    )\n\n    # Return launch description\n    return LaunchDescription([\n        declare_namespace_cmd,\n        declare_use_sim_time_cmd,\n        declare_autostart_cmd,\n        declare_params_file_cmd,\n        declare_bt_xml_cmd,\n        declare_map_subscribe_transient_local_cmd,\n        start_nav2_node,\n        start_planner_server,\n        start_controller_server,\n        start_bt_navigator,\n        start_lifecycle_manager\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,o.jsx)(e.h3,{id:"a-path-planning-implementation",children:"A* Path Planning Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import heapq\nimport numpy as np\n\nclass AStarPlanner:\n    def __init__(self, costmap, resolution=0.05):\n        self.costmap = costmap\n        self.resolution = resolution\n        self.height, self.width = costmap.shape\n\n    def plan_path(self, start, goal):\n        """\n        Plan path using A* algorithm\n\n        Args:\n            start: tuple (x, y) in meters\n            goal: tuple (x, y) in meters\n\n        Returns:\n            path: list of (x, y) tuples in meters\n        """\n        # Convert world coordinates to grid coordinates\n        start_grid = self.world_to_grid(start)\n        goal_grid = self.world_to_grid(goal)\n\n        # Check if start and goal are valid\n        if not self.is_valid_cell(start_grid) or not self.is_valid_cell(goal_grid):\n            return []\n\n        # Initialize open and closed sets\n        open_set = [(0, start_grid)]  # (f_score, (x, y))\n        heapq.heapify(open_set)\n\n        came_from = {}\n        g_score = {start_grid: 0}\n        f_score = {start_grid: self.heuristic(start_grid, goal_grid)}\n\n        while open_set:\n            current = heapq.heappop(open_set)[1]\n\n            if current == goal_grid:\n                return self.reconstruct_path(came_from, current)\n\n            # Check neighbors\n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + self.distance(current, neighbor)\n\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = g_score[neighbor] + self.heuristic(neighbor, goal_grid)\n\n                    # Add to open set if not already there\n                    if neighbor not in [item[1] for item in open_set]:\n                        heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n        return []  # No path found\n\n    def heuristic(self, pos1, pos2):\n        """Calculate heuristic (Manhattan distance)"""\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def distance(self, pos1, pos2):\n        """Calculate distance between two positions"""\n        dx = pos1[0] - pos2[0]\n        dy = pos1[1] - pos2[1]\n        return np.sqrt(dx*dx + dy*dy)\n\n    def get_neighbors(self, pos):\n        """Get valid neighboring cells"""\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip current cell\n\n                neighbor = (pos[0] + dx, pos[1] + dy)\n\n                if self.is_valid_cell(neighbor) and self.is_traversable(neighbor):\n                    neighbors.append(neighbor)\n\n        return neighbors\n\n    def is_valid_cell(self, pos):\n        """Check if position is within bounds"""\n        x, y = pos\n        return 0 <= x < self.width and 0 <= y < self.height\n\n    def is_traversable(self, pos):\n        """Check if cell is traversable (cost < 253, which is lethal obstacle in costmap)"""\n        x, y = pos\n        return self.costmap[y, x] < 253\n\n    def world_to_grid(self, world_pos):\n        """Convert world coordinates to grid coordinates"""\n        x_world, y_world = world_pos\n        x_grid = int((x_world + self.width * self.resolution / 2) / self.resolution)\n        y_grid = int((y_world + self.height * self.resolution / 2) / self.resolution)\n        return (x_grid, y_grid)\n\n    def grid_to_world(self, grid_pos):\n        """Convert grid coordinates to world coordinates"""\n        x_grid, y_grid = grid_pos\n        x_world = x_grid * self.resolution - self.width * self.resolution / 2\n        y_world = y_grid * self.resolution - self.height * self.resolution / 2\n        return (x_world, y_world)\n\n    def reconstruct_path(self, came_from, current):\n        """Reconstruct path from came_from dictionary"""\n        path = [current]\n        while current in came_from:\n            current = came_from[current]\n            path.append(current)\n\n        # Convert grid coordinates back to world coordinates\n        world_path = [self.grid_to_world(pos) for pos in reversed(path)]\n        return world_path\n'})}),"\n",(0,o.jsx)(e.h3,{id:"dijkstras-algorithm-implementation",children:"Dijkstra's Algorithm Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import heapq\nimport numpy as np\n\nclass DijkstraPlanner:\n    def __init__(self, costmap, resolution=0.05):\n        self.costmap = costmap\n        self.resolution = resolution\n        self.height, self.width = costmap.shape\n\n    def plan_path(self, start, goal):\n        """\n        Plan path using Dijkstra\'s algorithm\n\n        Args:\n            start: tuple (x, y) in meters\n            goal: tuple (x, y) in meters\n\n        Returns:\n            path: list of (x, y) tuples in meters\n        """\n        start_grid = self.world_to_grid(start)\n        goal_grid = self.world_to_grid(goal)\n\n        if not self.is_valid_cell(start_grid) or not self.is_valid_cell(goal_grid):\n            return []\n\n        # Initialize distances and previous nodes\n        distances = {}\n        previous = {}\n        visited = set()\n\n        # Priority queue: (distance, (x, y))\n        pq = [(0, start_grid)]\n        distances[start_grid] = 0\n\n        while pq:\n            current_dist, current = heapq.heappop(pq)\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            if current == goal_grid:\n                break\n\n            for neighbor in self.get_neighbors(current):\n                if neighbor in visited:\n                    continue\n\n                edge_weight = self.get_edge_weight(current, neighbor)\n                new_distance = distances[current] + edge_weight\n\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    previous[neighbor] = current\n                    heapq.heappush(pq, (new_distance, neighbor))\n\n        # Reconstruct path\n        if goal_grid not in previous:\n            return []  # No path found\n\n        path = self.reconstruct_path(previous, start_grid, goal_grid)\n        return path\n\n    def get_edge_weight(self, pos1, pos2):\n        """Calculate edge weight based on costmap values"""\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Get cost of destination cell\n        cost = self.costmap[y2, x2]\n\n        # Normalize cost (costmap values are typically 0-254)\n        normalized_cost = cost / 254.0\n\n        # Calculate geometric distance\n        dx = x2 - x1\n        dy = y2 - y1\n        geometric_distance = np.sqrt(dx*dx + dy*dy)\n\n        # Combined weight\n        weight = geometric_distance * (1 + normalized_cost)\n        return weight\n\n    def get_neighbors(self, pos):\n        """Get valid neighboring cells"""\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n\n                neighbor = (pos[0] + dx, pos[1] + dy)\n\n                if self.is_valid_cell(neighbor) and self.is_traversable(neighbor):\n                    neighbors.append(neighbor)\n\n        return neighbors\n\n    def is_valid_cell(self, pos):\n        """Check if position is within bounds"""\n        x, y = pos\n        return 0 <= x < self.width and 0 <= y < self.height\n\n    def is_traversable(self, pos):\n        """Check if cell is traversable"""\n        x, y = pos\n        return self.costmap[y, x] < 253\n\n    def world_to_grid(self, world_pos):\n        """Convert world coordinates to grid coordinates"""\n        x_world, y_world = world_pos\n        x_grid = int((x_world + self.width * self.resolution / 2) / self.resolution)\n        y_grid = int((y_world + self.height * self.resolution / 2) / self.resolution)\n        return (x_grid, y_grid)\n\n    def grid_to_world(self, grid_pos):\n        """Convert grid coordinates to world coordinates"""\n        x_grid, y_grid = grid_pos\n        x_world = x_grid * self.resolution - self.width * self.resolution / 2\n        y_world = y_grid * self.resolution - self.height * self.resolution / 2\n        return (x_world, y_world)\n\n    def reconstruct_path(self, previous, start, goal):\n        """Reconstruct path from previous dictionary"""\n        path = []\n        current = goal\n        while current != start:\n            path.append(current)\n            current = previous[current]\n        path.append(start)\n\n        # Convert to world coordinates\n        world_path = [self.grid_to_world(pos) for pos in reversed(path)]\n        return world_path\n'})}),"\n",(0,o.jsx)(e.h2,{id:"behavior-trees-in-navigation",children:"Behavior Trees in Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"custom-behavior-tree-nodes",children:"Custom Behavior Tree Nodes"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import py_trees\nfrom geometry_msgs.msg import PoseStamped\nfrom nav2_msgs.action import NavigateToPose\nimport rclpy\nfrom rclpy.action import ActionClient\n\nclass NavigateToPoseBehavior(py_trees.behaviour.Behaviour):\n    def __init__(self, name, node):\n        super(NavigateToPoseBehavior, self).__init__(name)\n        self.node = node\n        self.navigate_to_pose_client = ActionClient(\n            self.node, NavigateToPose, \'navigate_to_pose\'\n        )\n        self.goal_sent = False\n        self.goal_pose = None\n\n    def initialise(self):\n        """Initialise the behavior tree node"""\n        self.node.get_logger().info(f"Sending navigation goal: {self.goal_pose}")\n\n        # Wait for action server\n        if not self.navigate_to_pose_client.wait_for_server(timeout_sec=5.0):\n            self.feedback_message = "NavigateToPose action server not available"\n            return py_trees.common.Status.FAILURE\n\n        # Send goal\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose = self.goal_pose\n        self.navigate_to_pose_client.send_goal_async(goal_msg)\n        self.goal_sent = True\n\n    def update(self):\n        """Update the behavior tree node"""\n        if not self.goal_sent:\n            return py_trees.common.Status.RUNNING\n\n        # Check if goal is still active\n        # In a real implementation, you would check the actual goal status\n        # This is a simplified version\n        return py_trees.common.Status.RUNNING\n\n    def terminate(self, new_status):\n        """Terminate the behavior tree node"""\n        self.node.get_logger().info(f"Terminated with status: {new_status}")\n\ndef create_simple_navigation_tree(node):\n    """Create a simple navigation behavior tree"""\n\n    # Root\n    root = py_trees.composites.Sequence("NavigationSequence")\n\n    # Create navigation behavior\n    nav_behavior = NavigateToPoseBehavior("NavigateToPose", node)\n\n    # Add to root\n    root.add_child(nav_behavior)\n\n    return root\n'})}),"\n",(0,o.jsx)(e.h2,{id:"navigation-with-isaac-ros-integration",children:"Navigation with Isaac ROS Integration"}),"\n",(0,o.jsx)(e.h3,{id:"isaac-ros-perception-integration",children:"Isaac ROS Perception Integration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, PointCloud2\nfrom nav_msgs.msg import OccupancyGrid\nfrom geometry_msgs.msg import PoseStamped\nfrom std_msgs.msg import Bool\nimport numpy as np\n\nclass IsaacPerceptionNavIntegration(Node):\n    def __init__(self):\n        super().__init__(\'isaac_perception_nav_integration\')\n\n        # Subscribe to perception outputs\n        self.semantic_seg_sub = self.create_subscription(\n            Image,\n            \'/segmentation_mask\',\n            self.semantic_callback,\n            10\n        )\n\n        self.depth_sub = self.create_subscription(\n            Image,\n            \'/depth\',\n            self.depth_callback,\n            10\n        )\n\n        self.object_detection_sub = self.create_subscription(\n            Image,\n            \'/detections\',\n            self.detection_callback,\n            10\n        )\n\n        # Publish enhanced costmaps\n        self.enhanced_costmap_pub = self.create_publisher(\n            OccupancyGrid,\n            \'/enhanced_costmap\',\n            10\n        )\n\n        # Subscribe to navigation status\n        self.nav_status_sub = self.create_subscription(\n            Bool,\n            \'/navigation_active\',\n            self.nav_status_callback,\n            10\n        )\n\n        # Navigation goal publisher\n        self.nav_goal_pub = self.create_publisher(\n            PoseStamped,\n            \'/goal_pose\',\n            10\n        )\n\n        # Perception data storage\n        self.semantic_map = None\n        self.depth_map = None\n        self.detections = None\n        self.navigation_active = False\n\n        # Integration parameters\n        self.dynamic_obstacle_threshold = 0.5  # Confidence threshold\n        self.traversable_classes = [\'road\', \'sidewalk\', \'grass\']\n        self.obstacle_classes = [\'car\', \'person\', \'tree\', \'building\']\n\n    def semantic_callback(self, msg):\n        """Process semantic segmentation data"""\n        # Convert ROS image to numpy array\n        # This is simplified - in practice would use cv_bridge\n        semantic_data = np.frombuffer(msg.data, dtype=np.uint8)\n        semantic_map = semantic_data.reshape((msg.height, msg.width))\n\n        self.semantic_map = semantic_map\n        self.update_costmap_from_semantics()\n\n    def depth_callback(self, msg):\n        """Process depth data"""\n        # Convert depth image to numpy array\n        depth_data = np.frombuffer(msg.data, dtype=np.float32)\n        depth_map = depth_data.reshape((msg.height, msg.width))\n\n        self.depth_map = depth_map\n        self.update_costmap_from_depth()\n\n    def detection_callback(self, msg):\n        """Process object detection data"""\n        # Process object detection results\n        # This would parse detection messages\n        self.detections = msg\n        self.update_costmap_from_detections()\n\n    def nav_status_callback(self, msg):\n        """Update navigation status"""\n        self.navigation_active = msg.data\n\n    def update_costmap_from_semantics(self):\n        """Update costmap based on semantic segmentation"""\n        if self.semantic_map is None or not self.navigation_active:\n            return\n\n        # Update costmap based on semantic classes\n        height, width = self.semantic_map.shape\n        costmap = np.zeros((height, width), dtype=np.uint8)\n\n        for row in range(height):\n            for col in range(width):\n                semantic_class = self.semantic_map[row, col]\n\n                if semantic_class in self.obstacle_classes:\n                    costmap[row, col] = 254  # Lethal obstacle\n                elif semantic_class in self.traversable_classes:\n                    costmap[row, col] = 0    # Free space\n                else:\n                    costmap[row, col] = 128  # Unknown\n\n        # Publish enhanced costmap\n        self.publish_enhanced_costmap(costmap)\n\n    def update_costmap_from_depth(self):\n        """Update costmap based on depth information"""\n        if self.depth_map is None or not self.navigation_active:\n            return\n\n        # Update costmap based on depth thresholds\n        # Mark areas as obstacles if depth suggests proximity to objects\n        height, width = self.depth_map.shape\n        costmap = np.zeros((height, width), dtype=np.uint8)\n\n        for row in range(height):\n            for col in range(width):\n                depth = self.depth_map[row, col]\n\n                if depth < 0.5:  # Close to obstacle\n                    costmap[row, col] = 254\n                elif depth < 1.0:  # Near obstacle\n                    costmap[row, col] = 200\n                elif depth > 10.0:  # Far away\n                    costmap[row, col] = 0\n\n        # Blend with semantic costmap\n        self.publish_enhanced_costmap(costmap)\n\n    def update_costmap_from_detections(self):\n        """Update costmap based on object detections"""\n        if self.detections is None or not self.navigation_active:\n            return\n\n        # Update costmap based on detected objects\n        # Mark detection bounding boxes as obstacles\n        # This is a simplified implementation\n        pass\n\n    def publish_enhanced_costmap(self, costmap_data):\n        """Publish enhanced costmap combining multiple perception sources"""\n        msg = OccupancyGrid()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = "map"\n\n        # Set map metadata\n        msg.info.resolution = 0.05  # meters per cell\n        msg.info.width = costmap_data.shape[1]\n        msg.info.height = costmap_data.shape[0]\n        msg.info.origin.position.x = 0.0\n        msg.info.origin.position.y = 0.0\n        msg.info.origin.orientation.w = 1.0\n\n        # Flatten costmap data\n        msg.data = costmap_data.flatten().tolist()\n\n        self.enhanced_costmap_pub.publish(msg)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"navigation-recovery-behaviors",children:"Navigation Recovery Behaviors"}),"\n",(0,o.jsx)(e.h3,{id:"custom-recovery-behaviors",children:"Custom Recovery Behaviors"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Bool\n\nclass NavigationRecovery(Node):\n    def __init__(self):\n        super().__init__(\'navigation_recovery\')\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.recovery_status_pub = self.create_publisher(Bool, \'/recovery_active\', 10)\n\n        # Recovery behaviors\n        self.active_recovery = None\n        self.recovery_timer = None\n\n        # Parameters\n        self.backup_speed = -0.1\n        self.backup_duration = 2.0\n        self.spin_angle = 1.57  # 90 degrees\n        self.wait_duration = 5.0\n\n    def execute_spin_recovery(self):\n        """Execute spin recovery behavior"""\n        self.get_logger().info("Executing spin recovery")\n        self.active_recovery = "spin"\n\n        # Create timer for recovery duration\n        self.recovery_timer = self.create_timer(\n            0.1, self.spin_recovery_callback\n        )\n\n        self.start_recovery_timer(self.spin_angle / 0.5)  # Assuming 0.5 rad/s spin speed\n\n    def spin_recovery_callback(self):\n        """Spin recovery callback"""\n        if self.active_recovery != "spin":\n            return\n\n        cmd_vel = Twist()\n        cmd_vel.angular.z = 0.5  # Spin at 0.5 rad/s\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def execute_backup_recovery(self):\n        """Execute backup recovery behavior"""\n        self.get_logger().info("Executing backup recovery")\n        self.active_recovery = "backup"\n\n        # Create timer for recovery duration\n        self.recovery_timer = self.create_timer(\n            0.1, self.backup_recovery_callback\n        )\n\n        self.start_recovery_timer(self.backup_duration)\n\n    def backup_recovery_callback(self):\n        """Backup recovery callback"""\n        if self.active_recovery != "backup":\n            return\n\n        cmd_vel = Twist()\n        cmd_vel.linear.x = self.backup_speed\n        self.cmd_vel_pub.publish(cmd_vel)\n\n    def execute_wait_recovery(self):\n        """Execute wait recovery behavior"""\n        self.get_logger().info("Executing wait recovery")\n        self.active_recovery = "wait"\n\n        # Stop robot\n        cmd_vel = Twist()\n        cmd_vel.linear.x = 0.0\n        cmd_vel.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd_vel)\n\n        # Create timer for wait duration\n        self.recovery_timer = self.create_timer(\n            self.wait_duration, self.wait_recovery_complete\n        )\n\n    def wait_recovery_complete(self):\n        """Complete wait recovery"""\n        self.get_logger().info("Wait recovery completed")\n        self.cleanup_recovery()\n\n    def start_recovery_timer(self, duration):\n        """Start timer for recovery behavior"""\n        self.recovery_start_time = self.get_clock().now()\n        self.recovery_duration = duration\n\n        # Create periodic timer to check if recovery should stop\n        self.check_timer = self.create_timer(0.1, self.check_recovery_completion)\n\n    def check_recovery_completion(self):\n        """Check if recovery behavior should complete"""\n        if self.active_recovery:\n            elapsed = (self.get_clock().now() - self.recovery_start_time).nanoseconds / 1e9\n\n            if elapsed >= self.recovery_duration:\n                self.cleanup_recovery()\n\n    def cleanup_recovery(self):\n        """Clean up active recovery behavior"""\n        if self.active_recovery:\n            self.get_logger().info(f"Cleaning up {self.active_recovery} recovery")\n\n            # Stop robot\n            cmd_vel = Twist()\n            cmd_vel.linear.x = 0.0\n            cmd_vel.angular.z = 0.0\n            self.cmd_vel_pub.publish(cmd_vel)\n\n            # Cancel timers\n            if self.recovery_timer:\n                self.recovery_timer.cancel()\n            if self.check_timer:\n                self.check_timer.cancel()\n\n            # Reset active recovery\n            self.active_recovery = None\n\n            # Publish recovery status\n            status_msg = Bool()\n            status_msg.data = False\n            self.recovery_status_pub.publish(status_msg)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"multi-level-path-planning",children:"Multi-Level Path Planning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class MultiLevelPathPlanner:\n    def __init__(self, global_costmap, local_costmap):\n        self.global_costmap = global_costmap\n        self.local_costmap = local_costmap\n\n        # Hierarchical planners\n        self.coarse_planner = AStarPlanner(global_costmap, resolution=0.5)  # Coarse grid\n        self.fine_planner = AStarPlanner(local_costmap, resolution=0.05)   # Fine grid\n\n    def plan_path_multilevel(self, start, goal):\n        """\n        Plan path using multilevel approach:\n        1. Coarse planning for global path\n        2. Fine planning for local obstacle avoidance\n        """\n        # 1. Plan coarse path at global level\n        coarse_path = self.coarse_planner.plan_path(start, goal)\n\n        if not coarse_path:\n            return []\n\n        # 2. Refine path using fine resolution\n        refined_path = []\n\n        for i in range(len(coarse_path) - 1):\n            segment_start = coarse_path[i]\n            segment_end = coarse_path[i + 1]\n\n            # Plan fine-grained path between coarse waypoints\n            fine_segment = self.fine_planner.plan_path(segment_start, segment_end)\n\n            if fine_segment:\n                refined_path.extend(fine_segment[:-1])  # Exclude last point to avoid duplication\n            else:\n                # If fine planning fails, use the coarse path\n                refined_path.append(segment_start)\n\n        # Add final goal point\n        if coarse_path:\n            refined_path.append(coarse_path[-1])\n\n        return refined_path\n'})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"1-navigation-failures",children:"1. Navigation Failures"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot fails to reach goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check costmap inflation settings"}),"\n",(0,o.jsx)(e.li,{children:"Verify localization accuracy"}),"\n",(0,o.jsx)(e.li,{children:"Adjust path planning parameters"}),"\n",(0,o.jsx)(e.li,{children:"Check for sensor issues"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"2-oscillation-in-path-following",children:"2. Oscillation in Path Following"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot oscillates around path"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Increase lookahead distance"}),"\n",(0,o.jsx)(e.li,{children:"Adjust PID controller gains"}),"\n",(0,o.jsx)(e.li,{children:"Smooth path with spline interpolation"}),"\n",(0,o.jsx)(e.li,{children:"Check velocity limits"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"3-local-minima-in-navigation",children:"3. Local Minima in Navigation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Robot gets stuck in local minima"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Implement better obstacle avoidance"}),"\n",(0,o.jsx)(e.li,{children:"Use more sophisticated local planners"}),"\n",(0,o.jsx)(e.li,{children:"Add recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Improve costmap resolution"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"4-performance-issues",children:"4. Performance Issues"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Problem"}),": Navigation system too slow"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Solutions"}),":","\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce costmap resolution"}),"\n",(0,o.jsx)(e.li,{children:"Optimize path planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Use multi-threading"}),"\n",(0,o.jsx)(e.li,{children:"Implement path caching"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-isaac-ros",children:"Integration with Isaac ROS"}),"\n",(0,o.jsx)(e.h3,{id:"launch-configuration-for-isaac-ros-navigation",children:"Launch Configuration for Isaac ROS Navigation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Isaac ROS Navigation Launch File --\x3e\n<launch>\n  \x3c!-- Map server --\x3e\n  <node pkg="nav2_map_server" exec="map_server" name="map_server">\n    <param name="yaml_filename" value="$(find-pkg-share my_maps)/maps/my_map.yaml"/>\n  </node>\n\n  \x3c!-- AMCL localization --\x3e\n  <node pkg="nav2_amcl" exec="amcl" name="amcl">\n    <param name="set_initial_pose" value="true"/>\n    <param name="initial_pose.x" value="0.0"/>\n    <param name="initial_pose.y" value="0.0"/>\n    <param name="initial_pose.z" value="0.0"/>\n    <param name="initial_pose.yaw" value="0.0"/>\n  </node>\n\n  \x3c!-- Isaac ROS perception nodes --\x3e\n  <node pkg="isaac_ros_visual_slam" exec="isaac_ros_visual_slam" name="visual_slam">\n    <param name="enable_occupancy_map_generation" value="true"/>\n  </node>\n\n  \x3c!-- Isaac perception to Nav2 integration --\x3e\n  <node pkg="my_perception_integration" exec="perception_nav_integration" name="perception_nav_integration"/>\n\n  \x3c!-- Navigation stack --\x3e\n  <include file="$(find-pkg-share nav2_bringup)/launch/navigation_launch.py">\n    <arg name="use_sim_time" value="false"/>\n    <arg name="params_file" value="$(find-pkg-share my_robot_navigation)/config/nav2_params.yaml"/>\n  </include>\n\n  \x3c!-- RViz for visualization --\x3e\n  <node pkg="rviz2" exec="rviz2" name="rviz2" args="-d $(find-pkg-share nav2_bringup)/rviz/nav2_default_view.rviz"/>\n</launch>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Navigation and path planning using Nav2 provides a comprehensive solution for autonomous robot navigation. The system combines global path planning with local obstacle avoidance, recovery behaviors, and sophisticated costmap management. By integrating with Isaac ROS perception systems, robots can achieve robust navigation in complex environments. Proper configuration and tuning of the various parameters are essential for optimal performance. The multilevel approach and behavior tree architecture provide flexibility and robustness for real-world navigation challenges."})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(_,{...n})}):_(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>r,x:()=>s});var t=a(6540);const o={},i=t.createContext(o);function r(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);